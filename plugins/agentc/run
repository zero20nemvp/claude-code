#!/usr/bin/env ruby
# Auto-generated by context-lock - standalone decoder/executor
# Usage: ./run script.sh.locked [args...]
require 'yaml'
require 'open3'

INTERPRETERS = {
  '.sh' => 'bash', '.bash' => 'bash', '.zsh' => 'zsh',
  '.py' => 'python3', '.pyw' => 'python3',
  '.rb' => 'ruby',
  '.js' => 'node', '.mjs' => 'node',
  '.pl' => 'perl', '.lua' => 'lua', '.php' => 'php'
}.freeze

def find_key_file(script_dir)
  # Get plugin name from script_dir for centralized key lookup
  plugin_name = File.basename(script_dir)
  candidates = [
    # Centralized key location (preferred)
    File.join(Dir.home, '.config', 'context-lock', 'keys', plugin_name, 'lock.yml'),
    File.join(Dir.home, '.config', 'context-lock', plugin_name, 'lock.yml'),
    File.join(Dir.home, '.config', 'context-lock', 'lock.yml'),
    # Local fallbacks
    File.join(script_dir, 'lock.yml'),
    File.join(script_dir, '..', 'lock.yml')
  ]
  candidates.find { |f| File.exist?(f) }
end

def detect_interpreter(file_path, content)
  # Check shebang first
  if content.start_with?('#!')
    shebang = content.lines.first.strip[2..].strip
    if shebang.start_with?('/usr/bin/env ')
      return shebang.sub('/usr/bin/env ', '').split.first
    end
    return shebang.split.first
  end
  # Fall back to extension
  ext = File.extname(file_path.sub(/\.locked$/, '')).downcase
  INTERPRETERS[ext] || 'bash'
end

# Main
if ARGV.empty?
  warn "Usage: ./run <file.locked> [args...]"
  exit 1
end

script_dir = File.dirname(File.expand_path(__FILE__))
locked_file = ARGV.shift
locked_file = File.join(script_dir, locked_file) unless locked_file.start_with?('/')

unless File.exist?(locked_file)
  warn "Error: File not found: #{locked_file}"
  exit 1
end

key_file = find_key_file(script_dir)
unless key_file
  warn "Error: lock.yml not found"
  exit 1
end

# Load vocabulary and invert (word->id becomes id->word)
key_data = YAML.safe_load(File.read(key_file), permitted_classes: [Symbol], symbolize_names: true)
vocab = key_data[:vocabulary].invert  # id -> word

# Decode: replace space-separated token IDs with original words
locked_content = File.read(locked_file)
decoded = locked_content.split(' ').map { |id| vocab[id.to_i] || "[UNKNOWN:#{id}]" }.join

# Detect interpreter and execute
interp = detect_interpreter(locked_file, decoded)

# Build command with proper stdin handling for each interpreter
cmd = case interp
      when /bash|sh|zsh/
        [interp, '-s', '--', *ARGV]
      when /python/
        [interp, '-', *ARGV]
      when /ruby/
        [interp, '--', *ARGV]
      when /node/
        [interp, '-', *ARGV]
      else
        [interp, *ARGV]
      end

# Execute via stdin pipe
Open3.popen3(*cmd) do |stdin, stdout, stderr, wait_thr|
  stdin.write(decoded)
  stdin.close
  print stdout.read
  warn stderr.read
  exit wait_thr.value.exitstatus
end
